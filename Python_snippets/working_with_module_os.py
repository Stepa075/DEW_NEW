import os

# При доступе к os.name, вы получите информацию о том, с какой платформой вы работаете.

print(os.name)  # ответ: nt

# Это дает вам полезную информацию, такую как количество процессоров, тип ОЗУ, имя компьютера, и так далее.

print(os.environ)

# вы можете получить доступ к значениям среды, пользуясь обычными словарными методами. Полезность использования
# os.getenv() вместо словаря os.environ заключается в том, что если вы находитесь в положении, когда вам нужно
# получить доступ к переменной среды, которая не существует, функция getenv попросту ничего не сделает. Если вы
# попытаетесь сделать то же самое, пользуясь os.environ, вы получите уведомление об ошибке.

print(os.environ["TMP"])  # C:\\Users\\mike\\AppData\\Local\\Temp
print(os.getenv("TMP"))  # C:\\Users\\mike\\AppData\\Local\\Temp

# Функция os.chdir позволяет нам вносить изменения в каталоге, который мы в данный момент используем в сессии. Если
# вам нужно знать, какой путь вы в данный момент используете, для этой нужно вызвать os.getcwd(). Указанный код
# демонстрирует нам, что мы открыли директорию по умолчанию в Пайтоне, после запуска данного кода в IDLE. После этого
# мы изменили целевую папку, при помощи os.chdir(). Наконец, мы вызывали os.getcwd() еще раз, чтобы убедиться,
# что все изменения были выполнены правильно.

print(os.getcwd())  # C:\\Python27

os.chdir(r"C:\Users\mike\Documents")
print(os.getcwd())  # C:\\Users\\mike\\Documents

# Эти два метода используются для создания папок. Первая, os.mkdir(), позволяет создать одну папку. Первая строка
# кода создает папку под названием test в определенном каталоге. Вы можете использовать эти модули в предыдущем
# разделе, чтобы узнать, где именно вы запустили свой код, на случай, если вы забыли. Во втором примере мы назначили
# путь к переменной, затем к os.mkdir(). Это позволяет вам создать папку в любой точке вашей системы,
# где есть доступ. Функция os.makedirs() создает промежуточные папки в пути, если их там нет. В целом, это значит,
# что вы создали путь, в котором размещены папки.

os.mkdir("test")
path = r'C:\Users\mike\Documents\pytest'
os.mkdir(path)

# Лично я часто прибегал к данному решению, когда была необходимость
# создания журнала, с датированной структурой, например Год\Месяц\День. Давайте взглянем на пример:

path = r'C:\Users\mike\Documents\pytest\2014\02\19'
os.makedirs(path)

# Этот код просто создал кучу папок! Если в вашей системе все еще есть папка pytest, то в ней появится папка 2014,
# в которой также есть папка, в которой, удивительно, находится еще одна.

# Функции os.remove() и os.rmdir() используются для удаления файлов и каталогов соответственно.

os.remove("test.txt")

# Этот фрагмент кода пытается удалить файл под названием test.txt из вашего рабочего каталога. Если модуль не может
# найти файл, должно появиться уведомление о той или иной ошибке. Ошибка также возникнет, если файл уже используется
# (другими словами закрыт), или у вас нет разрешения для удаления данного файла. Возможно, вы хотите проверить
# os.unlink, который выполняет ту же функцию. Термин unlink – привычное для Unix название данной процедуры. Взглянем
# на пример работы os.rmdir():

os.rmdir("pytest")

# Данный код попытается удалить каталог под названием pytest из каталога, используемого в данный момент в работе. В
# случае, если это удалось, каталог pytest исчезнет. Ошибка может возникнуть, если каталога с таким названием не
# существует, если у вас нет разрешения на его удаление, или если каталог не пустой. Вам возможно хочется взглянуть
# на os.removedirs(), который может удалить пустые вложенные каталоги.

# Функция os.rename() применяется тогда, когда нужно переименовать файл или папку. В этом примере, мы указали
# os.rename на то, что нужно переименовать файл под названием test.txt на pytest.txt. Это произойдет в каталоге,
# с которым мы в данный момент работаем. Ошибка может возникнуть в том случае, если вы попытаетесь переименовать
# несуществующий файл, или если у вас нет доступа к данной операции. Также существует функция os.renames,
# которая меняет название папки или файла соответственно.

os.rename("test.txt", "pytest.txt")

# Метод os.startfile() позволяет нам «запустить» файл в привязанной к нему программе. Другими словами,
# мы можем открыть файл вместе с привязанной к нему программой, как когда вы открываете файл PDF двойным щелчком,
# и он открывается в программе Adobe Reader.

os.startfile(r'C:\Users\mike\Documents\labels.pdf')

# Метод os.walk() дает нам возможность для итерации на корневом уровне пути. Это значит, что мы можем назначить путь
# к этой функции и получить доступ ко всем её подкаталогам и файлам. Используем одну из папок Пайтон, при помощи
# которой мы можем проверить данную функцию. Мы используем C:\Python27\Tools

path = r'C:\Python27\Tools'

for root, dirs, files in os.walk(path):
    print(root)

# Результат работы:

# Python
# C:\Python27\Tools
# C:\Python27\Tools\i18n
# C:\Python27\Tools\pynche
# C:\Python27\Tools\pynche\X
# C:\Python27\Tools\Scripts
# C:\Python27\Tools\versioncheck
# C:\Python27\Tools\webchecker

# Мы можем отобразить и весь список каталогов и файлов.

for root, dirs, files in os.walk(path):
    print(root)
    for _dir in dirs:
        print(_dir)

    for _file in files:
        print(_file)
# Эта часть кода покажет нам весьма большой объем, так что не будем демонстрировать всю выдачу, вы можете
# ознакомиться с содержимым сами.


# Функция basename вернет название файла пути. Пример:

os.path.basename(r'C:\Python27\Tools\pynche\ChipViewer.py')
# ChipViewer.py

# Это очень полезная функция, особенно в тех случаях, когда нужно использовать имя файла для
# наименования того или иного связанного с работой файла, например лог-файл. Такая ситуация возникает часто при
# работе с файлами данных.

# Функция dirname возвращает только часть каталога пути.

print(os.path.dirname(r'C:\Python27\Tools\pynche\ChipViewer.py'))
# C:\\Python27\\Tools\\pynche

# В данном примере мы просто возвращаем путь к каталогу. Это также полезно,
# когда вам нужно сохранить другие файлы рядом с тем, который вы обрабатываете в данный момент. Как и в случае с
# лог-файлом, упомянутым выше.

# Функция exists говорит нам, существует ли файл, или нет. Все что вам нужно, это указать ему путь.

os.path.exists(r'C:\Python27\Tools\pynche\ChipViewer.py')  # True
os.path.exists(r'C:\Python27\Tools\pynche\fake.py')  # False

# Методы isdir и isfile тесно связаны с методом exists, так как они также тестируют присутствие или отсутствие файлов
# или папок на тех или иных путях. Однако, isdir проверяет только пути к папкам, а isfile, соответственно,
# к файлам. Если вам нужно проверить путь, и не важно, папка это или файл, проще будет воспользоваться методом
# exists. В любом случае, взглянем на пару примеров:

os.path.isfile(r'C:\Python27\Tools\pynche\ChipViewer.py')  # True

os.path.isdir(r'C:\Python27\Tools\pynche\ChipViewer.py')  # False

os.path.isdir(r'C:\Python27\Tools\pynche')  # True

os.path.isfile(r'C:\Python27\Tools\pynche')  # False

# Метод join позволяет вам совместить несколько путей при помощи присвоенного разделителя. К примеру, в Windows,
# в роли разделителя выступает бэкслэш (косая черта, указывающая назад), однако в Linux функция разделителя присвоена
# косой черте, указывающей вперед (forward slash). Как это работает:

print(os.path.join(r'C:\Python27\Tools\pynche', 'ChipViewer.py'))
# C:\\Python27\\Tools\\pynche\\ChipViewer.py

# В данном примере мы совместили путь каталога и файла вместе,
# для получения рабочего пути. Обратите внимание на то, что метод join не указывает на то, какой результат в итоге
# вышел.

# Метод split разъединяет путь на кортеж, который содержит и файл и каталог. Взглянем на пример:

print(os.path.split(r'C:\Python27\Tools\pynche\ChipViewer.py'))
# ('C:\\Python27\\Tools\\pynche', 'ChipViewer.py')

# В данном примере показано, что происходит, когда мы указываем путь
# к файлу. Теперь взглянем на то, что происходит, если в конце пути нет названия файла:

print(os.path.split(r'C:\Python27\Tools\pynche'))
# (‘C:\Python27\Tools’, ‘pynche’)

# Данная функция берет путь и разъединяет его таким образом, что подпапка стала
# вторым элементом кортежа с остальной частью пути в первом элементе. Напоследок, взглянем на бытовой случай
# использования split:

dirname, fname = os.path.split(r'C:\Python27\Tools\pynche\ChipViewer.py')
print(dirname)
# C:\\Python27\\Tools\\pynche
print(fname)
# ChipViewer.py

# В данном примере указано, как сделать множественное назначение. Когда вы разъединяете путь,
# он становится кортежем, состоящим из двух частей. После того, как мы опробовали две переменные с левой части,
# первый элемент кортежа назначен к первой переменной, а второй элемент к второй переменной соответственно.
